/*
 * armSquareRoot.s
 *
 *  Created on: Jan 24, 2026
 *      Author: Sjiax
 */
.syntax unified
.global armSquareRoot
.section .text.rodata
 /**extern void armSqrt(float *x);
	R0--> pointer to input
*/
armSquareRoot:
	PUSH	{R4, R5}
	VLDR.f32	S0, [R0] 		//input
my_sqrt:
    // 1. Handle special cases (if S <= 0)
	VCMP.f32 S0, #0.0
    VMRS APSR_nzcv, FPSCR
    BLE     return_zero        // If s0 <= 0, return 0

    // 2. Initial Guess: x = s0
    VMOV.f32    S1, S0             // s1 is our 'x_n'

    // Load constant 0.5 into s3
    MOV     R1, #0x3F000000    // IEEE 754 for 0.5
    VMOV.f32    S3, R1

    // 3. Newton-Raphson Iteration Loop (8 iterations is usually enough for float)
    MOV     R1, #8             // Loop counter

loop:
    // Formula: x = 0.5 * (x + S/x)
    VDIV.f32    S2, S0, S1         // s2 = S / x_n
    VADD.f32    S1, S1, S2         // s1 = x_n + (S / x_n)
    VMUL.f32    S1, S1, S3         // s1 = 0.5 * (x_n + S/x_n)

    SUBS    R1, R1, #1         // Decrement counter
    BNE     loop               // Repeat

    // 4. Clean up and return
    VMOV.f32    S0, S1             // Move result to return register
    VSTR.f32 	S0, [R0]
    BX LR

return_zero:
    MOV.f32    s0, #0.0
    BX LR
